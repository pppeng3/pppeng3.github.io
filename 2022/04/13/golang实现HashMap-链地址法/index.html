<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta name="renderer" content="webkit"/>
    <meta name="force-rendering" content="webkit"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <script>if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode)) window.location.href="https://support.dmeng.net/upgrade-your-browser.html?referrer="+encodeURIComponent(window.location.href); </script>
    
    
        <link rel="shortcut icon" href="/images/favicon.ico">
    
     
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.2.30/dist/vuetify.min.css" rel="stylesheet">
    
<link rel="stylesheet" href="/css/main.css">

    
    







    
    
          

    
    
    
    
    <title>
        
            golang实现HashMap(链地址法) | PP&#39;s Blog
        
    </title>
    
    
<meta name="generator" content="Hexo 6.1.0"></head>
<body>
    <div id="app">
        <v-app>
            <v-content id="page">
                <v-container fluid>
                    <v-row>
                        <v-col cols="2" class="d-none d-md-block">
                            <div id="sidebar" class="float-right">
    <a href="/" rel="home">
        <v-avatar size=96>
            <img id="logo" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fcdnimg103.lizhi.fm%2Faudio_cover%2F2015%2F12%2F10%2F24907694592916743_320x320.jpg&amp;refer=http%3A%2F%2Fcdnimg103.lizhi.fm&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1652427358&amp;t=869256d6280ef33d7afbf15ab91a7192">     
        </v-avatar> 
    </a>
    <v-divider></v-divider>
    <div class="mini-menu">
        <v-btn icon href="/">
            <v-icon>home</v-icon>
        </v-btn>
        <v-btn icon href="/categories/">
            <v-icon>folder</v-icon>
        </v-btn>
        <v-btn icon href="/tags/">
            <v-icon>bookmark</v-icon>
        </v-btn>
        <v-btn icon @click="SetNightMode">
            <v-icon>{{ nightMode }}</v-icon>
        </v-btn>
    </div>
    <v-list id="main-menu" class="font-weight-bold" flat>
        
            
            <v-list-item href="/archives/" link>
            <v-list-item-icon><v-icon>archive</v-icon></v-list-item-icon>
            <v-list-item-content>
                Archives
            </v-list-item-content>
            </v-list-item>
        
            
            <v-list-item href="/about/" link>
            <v-list-item-icon><v-icon>account_circle</v-icon></v-list-item-icon>
            <v-list-item-content>
                About
            </v-list-item-content>
            </v-list-item>
        
            
            <v-list-item href="https://blog.apale7.cn/" link>
            <v-list-item-icon><v-icon>rss_feed</v-icon></v-list-item-icon>
            <v-list-item-content>
                我的博客
            </v-list-item-content>
            </v-list-item>
        
            
            <v-list-item href="https://hexo.io/zh-cn/docs/" link>
            <v-list-item-icon><v-icon>insert_drive_file</v-icon></v-list-item-icon>
            <v-list-item-content>
                说明文档
            </v-list-item-content>
            </v-list-item>
        
    </v-list>
    <v-divider></v-divider>
    
        <div class="post-toc">
            <a href="/2022/04/13/golang%E5%AE%9E%E7%8E%B0HashMap-%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95/" class="toc-header">Table of Contents</a>
            <div class="toc-content">
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AF%A6%E8%A7%A3HashMap"><span class="toc-number">1.</span> <span class="toc-text">一、详解HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HashMap"><span class="toc-number">1.1.</span> <span class="toc-text">1.HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.2.</span> <span class="toc-text">1.1 哈希冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%8B%89%E9%93%BE%E6%B3%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">1.2 拉链法优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90"><span class="toc-number">1.4.</span> <span class="toc-text">1.3 负载因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Redis-HashMap"><span class="toc-number">1.5.</span> <span class="toc-text">2.Redis HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Hash%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.</span> <span class="toc-text">2.2 Hash命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Golang-HashMap"><span class="toc-number">1.7.</span> <span class="toc-text">3.Golang HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.</span> <span class="toc-text">3.1 Map数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-ReHash%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%89%A9%E5%AE%B9"><span class="toc-number">1.9.</span> <span class="toc-text">3.2 ReHash渐进式扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E6%89%A9%E5%AE%B9%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.10.</span> <span class="toc-text">3.2.1 扩容前提条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%A2%9E%E9%87%8F%E6%89%A9%E5%AE%B9"><span class="toc-number">1.11.</span> <span class="toc-text">3.2.2 增量扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E7%AD%89%E9%87%8F%E6%89%A9%E5%AE%B9"><span class="toc-number">1.12.</span> <span class="toc-text">3.2.3 等量扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%94%A8Golang%E5%AE%9E%E7%8E%B0HashMap"><span class="toc-number">2.</span> <span class="toc-text">二、用Golang实现HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E5%BA%95%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">hash底层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-hash-amp-amp-golang-map-gt-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-number">4.</span> <span class="toc-text">redis hash &amp;&amp; golang map-&gt;并发安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rehash"><span class="toc-number">5.</span> <span class="toc-text">rehash</span></a></li></ol>
            </div>
        </div>
    

    <div id="footer">
        <div class="footer-social">
            
                
                <v-btn icon href="/" target="_blank">
                    <v-icon>fas fa-envelope</v-icon>
                </v-btn>
            
                
                <v-btn icon href="https://github.com/pppeng3" target="_blank">
                    <v-icon>fab fa-github</v-icon>
                </v-btn>
            
                
                <v-btn icon href="/" target="_blank">
                    <v-icon>fab fa-steam</v-icon>
                </v-btn>
            
                
                <v-btn icon href="/" target="_blank">
                    <v-icon>fab fa-weibo</v-icon>
                </v-btn>
            
        </div>
        <v-divider></v-divider>
        <div class="footer-content">
            
                <span id="busuanzi_container_site_uv" style="display: none;"> 
                    Total Visitors <span id="busuanzi_value_site_uv"></span>
                </span>
                <br>
            
            <span>Theme: <a target="_blank" rel="noopener" href="https://github.com/kb1000fx/hexo-theme-insulin">Insulin</a></span><br>
            <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span><br>
            <span>
                &copy; 2015 - 2022 
                PP
            </span>
        </div>
    </div>
</div>

                        </v-col>
                        <v-col cols="12" md="10">
                            <v-row>
  <v-col cols="12" md="8" align-self="end">
    <div id="site-header">
      <div id="site-title">
        <a href="/" rel="home">PP&#39;s Blog</a>
      </div>
      <div id="site-description"></div>
      <div id="mobile-menu" class="d-block d-md-none">
        <v-text-field label="请输入关键字" data-src="search.xml" v-model="searchHeaderValue" prepend-inner-icon="search" clearable clear-icon="clear" @keydown.enter="EnterSearch(searchHeaderValue,false)"></v-text-field>
        <div class="mobile-mini-menu">
          <v-btn icon href="/">
              <v-icon>home</v-icon>
          </v-btn>
          <v-btn icon href="/categories/">
              <v-icon>folder</v-icon>
          </v-btn>
          <v-btn icon href="/tags/">
              <v-icon>bookmark</v-icon>
          </v-btn>
          <v-btn icon @click="SetNightMode">
              <v-icon>{{ nightMode }}</v-icon>
          </v-btn>
          
            
            <v-btn icon href="/archives/">
              <v-icon>archive</v-icon>
            </v-btn>
          
            
            <v-btn icon href="/about/">
              <v-icon>account_circle</v-icon>
            </v-btn>
          
            
            <v-btn icon href="https://blog.apale7.cn/">
              <v-icon>rss_feed</v-icon>
            </v-btn>
          
            
            <v-btn icon href="https://hexo.io/zh-cn/docs/">
              <v-icon>insert_drive_file</v-icon>
            </v-btn>
          
        </div>
      </div>    
    </div>
  </v-col>  
  <v-col cols="4" align-self="end" class="d-none d-md-block">
    <v-col align-self="end">
      <v-text-field label="请输入关键字" data-src="search.xml" v-model="searchHeaderValue" prepend-icon="search" clearable clear-icon="clear" @keydown.enter="EnterSearch(searchHeaderValue,false)"></v-text-field>
    </v-col> 
  </v-col>
</v-row>

                            <v-card class="elevation-2 post-card">
    
    
        <div class="post-header">
  <a class="post-header-title font-weight-medium" href="/2022/04/13/golang%E5%AE%9E%E7%8E%B0HashMap-%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95/">golang实现HashMap(链地址法)</a>
  <div class="post-header-meta">   
    <span>
      <v-icon color="">event</v-icon>
      Posted on:&nbsp;2022-04-13
    </span>
    <span>
      <v-icon color="">event_available</v-icon>
      Edited on:&nbsp;2022-04-14
    </span>
    <span>
      <v-icon color="">folder</v-icon>
      In:&nbsp;<a class="category-link" href="/categories/golang-redis/">golang redis</a>
    </span>
    
    <span>
      <v-icon color="">visibility</v-icon>
      Views:&nbsp;<span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
    </span>
    
  </div>
</div>

    
    
    
    
    <div class="post-content typo">
        <h2 id="一、详解HashMap"><a href="#一、详解HashMap" class="headerlink" title="一、详解HashMap"></a><em>一、详解HashMap</em></h2><h3 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h3><h3 id="1-1-哈希冲突"><a href="#1-1-哈希冲突" class="headerlink" title="1.1 哈希冲突"></a>1.1 哈希冲突</h3><p>哈希冲突是指两个值经过哈希算法计算得到的哈希值相同,应该放在同一个槽内,这样就称为哈希冲突。<br>哈希冲突解决方案:<br>(1)开放地址法:也称再散列法,其基本思想是当关键字key的哈希地址p&#x3D;H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：<br>Hi&#x3D;（H（key）+di）% m i&#x3D;1，2，…，n<br>其中H（key）为哈希函数，m 为表长，di称为增量序列。<br>包含线性探测再散列(向后查空槽)、二次探测再散列(两侧反复横跳)以及伪随机探测再散列。<br>(2)再哈希法(新哈希算法)<br>(3)链地址法(槽拉链表解决)<br>(4)建立公共溢出区:将哈希表分为基本表和溢出表两部分,凡是和基本表发生冲突的元素一律填入冲突表。</p>
<h3 id="1-2-拉链法优缺点"><a href="#1-2-拉链法优缺点" class="headerlink" title="1.2 拉链法优缺点"></a>1.2 拉链法优缺点</h3><p><em>拉链法的优点</em><br>(1)拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；<br>(2)由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；<br>(3)开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；<br>(4)在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。<br><em>拉链法的缺点</em><br>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p>
<h3 id="1-3-负载因子"><a href="#1-3-负载因子" class="headerlink" title="1.3 负载因子"></a>1.3 负载因子</h3><p>负载因子用于衡量一个哈希表的冲突情况,公式如下:<br>负载因子 &#x3D; 键数量 &#x2F; Bucket数量<br>·哈希表需要控制负载因子在合适大小,超过其阈值就要进行rehash<br>    哈希因子过小,说明空间利用率低<br>    哈希因子过大,说明冲突严重,存取率低<br>·每个哈希表对哈希因子容忍程度不一样<br>    Redis负载因子大于1会触发Rehash<br>    Golang负载因子大于6.5时才会触发Rehash<br><em>这是因为Redis的每个Bucket只存一个键值对,而Go的Bucket可能存8个键值对,所以Go可以容忍更高的负载因子</em></p>
<h3 id="2-Redis-HashMap"><a href="#2-Redis-HashMap" class="headerlink" title="2.Redis HashMap"></a>2.Redis HashMap</h3><h3 id="2-2-Hash命令"><a href="#2-2-Hash命令" class="headerlink" title="2.2 Hash命令"></a>2.2 Hash命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td>HDEL key field1 [field2]</td>
<td align="center">删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td align="center">查看哈希表 key 中，指定的字段是否存在</td>
</tr>
<tr>
<td>HGET key field</td>
<td align="center">获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td>HGETALL key</td>
<td align="center">获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td>HINCRBY key field increment</td>
<td align="center">为哈希表 key 中的指定字段的整数值加上增量 increment</td>
</tr>
<tr>
<td>HINCRBYFLOAT key field increment</td>
<td align="center">为哈希表 key 中的指定字段的浮点数值加上增量 increment</td>
</tr>
<tr>
<td>HKEYS key</td>
<td align="center">获取所有哈希表中的字段</td>
</tr>
<tr>
<td>HLEN key</td>
<td align="center">获取哈希表中字段的数量</td>
</tr>
<tr>
<td>HMGET key field1 [field2]</td>
<td align="center">获取所有给定字段的值</td>
</tr>
<tr>
<td>HMSET key field1 value1 [field2 value2 ]</td>
<td align="center">同时将多个 field-value (域-值)对设置到哈希表 key 中</td>
</tr>
<tr>
<td>HSET key field value</td>
<td align="center">将哈希表 key 中的字段 field 的值设为 value</td>
</tr>
<tr>
<td>HSETNX key field value</td>
<td align="center">只有在字段 field 不存在时，设置哈希表字段的值</td>
</tr>
<tr>
<td>HVALS key</td>
<td align="center">获取哈希表中所有值</td>
</tr>
<tr>
<td>HSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td align="center">迭代哈希表中的键值对</td>
</tr>
</tbody></table>
<h3 id="3-Golang-HashMap"><a href="#3-Golang-HashMap" class="headerlink" title="3.Golang HashMap"></a>3.Golang HashMap</h3><h3 id="3-1-Map数据结构"><a href="#3-1-Map数据结构" class="headerlink" title="3.1 Map数据结构"></a>3.1 Map数据结构</h3><p>Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。<br>Go map在语言底层是通过如下的抽象结构来表征:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key  *Type <span class="comment">// Key type</span></span><br><span class="line">	Elem *Type <span class="comment">// Val (elem) type</span></span><br><span class="line"></span><br><span class="line">	Bucket *Type <span class="comment">// internal struct type representing a hash bucket</span></span><br><span class="line">	Hmap   *Type <span class="comment">// internal struct type representing the Hmap (map header object)</span></span><br><span class="line">	Hiter  *Type <span class="comment">// internal struct type representing hash iterator state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Key、Elem为Key、Value,由于go map支持多种数据类型,go会在预编译阶段推断具体的数据类型,Bucket是哈希桶,Hmap表征了map底层使用的HashTable的元信息,如当前HashTable中含有的元素数据、桶指针等, Hiter 是用于遍历 go map 的数据结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.</span></span><br><span class="line">	<span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">	count     <span class="type">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags     <span class="type">uint8</span></span><br><span class="line">	B         <span class="type">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">	noverflow <span class="type">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">	hash0     <span class="type">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [<span class="number">8</span>]<span class="type">uint8</span> <span class="comment">//存储哈希值的高8位</span></span><br><span class="line">    data    <span class="type">byte</span>[<span class="number">1</span>]  <span class="comment">//key value数据:key/key/key/.../value/value/value...</span></span><br><span class="line">    overflow *bmap   <span class="comment">//溢出bucket的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-ReHash渐进式扩容"><a href="#3-2-ReHash渐进式扩容" class="headerlink" title="3.2 ReHash渐进式扩容"></a>3.2 ReHash渐进式扩容</h3><h3 id="3-2-1-扩容前提条件"><a href="#3-2-1-扩容前提条件" class="headerlink" title="3.2.1 扩容前提条件"></a>3.2.1 扩容前提条件</h3><p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。 触发扩容的条件有二个：<br>(1)负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。<br>(2)overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</p>
<h3 id="3-2-2-增量扩容"><a href="#3-2-2-增量扩容" class="headerlink" title="3.2.2 增量扩容"></a>3.2.2 增量扩容</h3><p>当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。 考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p>
<p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):<br><img src="/../image/hashmap/0.png"></p>
<p>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。</p>
<p>当第8个键值对插入时，将会触发扩容，扩容后示意图如下：<br><img src="/../image/hashmap/1.png"></p>
<p>hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。 后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。</p>
<p>搬迁完成后的示意图如下：<br><img src="/../image/hashmap/2.png"><br>数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。 实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。</p>
<h3 id="3-2-3-等量扩容"><a href="#3-2-3-等量扩容" class="headerlink" title="3.2.3 等量扩容"></a>3.2.3 等量扩容</h3><p>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。 在极端场景下，比如不断的增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：<br><img src="/../image/hashmap/3.png"></p>
<p>上图可见，overflow的buckt中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。</p>
<h2 id="二、用Golang实现HashMap"><a href="#二、用Golang实现HashMap" class="headerlink" title="二、用Golang实现HashMap"></a><em>二、用Golang实现HashMap</em></h2><h2 id="hash底层"><a href="#hash底层" class="headerlink" title="hash底层"></a>hash底层</h2><h2 id="redis-hash-amp-amp-golang-map-gt-并发安全"><a href="#redis-hash-amp-amp-golang-map-gt-并发安全" class="headerlink" title="redis hash &amp;&amp; golang map-&gt;并发安全"></a>redis hash &amp;&amp; golang map-&gt;并发安全</h2><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	initSize = <span class="number">1</span> &lt;&lt; <span class="number">4</span> <span class="comment">//哈希数组初始大小</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HashKey <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetHash(mod <span class="type">int</span>) <span class="type">int</span><span class="comment">//哈希函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HashNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	key   HashKey</span><br><span class="line">	value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	next  *HashNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HashMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	nodes []*HashNode<span class="comment">//哈希数组</span></span><br><span class="line">	total <span class="type">int</span> <span class="comment">//当前元素数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HashMap)</span></span> init() &#123;</span><br><span class="line">	h.nodes = <span class="built_in">make</span>([]*HashNode, initSize)<span class="comment">//初始化哈希数组</span></span><br><span class="line">	h.total = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHashMap</span><span class="params">()</span></span> *HashMap &#123;</span><br><span class="line">	mp := &amp;HashMap&#123;&#125;</span><br><span class="line">	mp.init()</span><br><span class="line">	<span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HashMap)</span></span> Get(key HashKey) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	i := key.GetHash(<span class="built_in">cap</span>(h.nodes))<span class="comment">//计算hashcode</span></span><br><span class="line">	<span class="keyword">for</span> head := h.nodes[i]; head != <span class="literal">nil</span>; head = head.next &#123;<span class="comment">//遍历hashcode对应的链表</span></span><br><span class="line">		<span class="keyword">if</span> head.key == key &#123;</span><br><span class="line">			ok = <span class="literal">true</span></span><br><span class="line">			value = head.value</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HashMap)</span></span> Set(key HashKey, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	i := key.GetHash(<span class="built_in">cap</span>(h.nodes))<span class="comment">//计算hashcode</span></span><br><span class="line">	<span class="keyword">for</span> head := h.nodes[i]; head != <span class="literal">nil</span>; head = head.next &#123;<span class="comment">//遍历hashcode对应的链表</span></span><br><span class="line">		<span class="keyword">if</span> head.key == key &#123;</span><br><span class="line">			<span class="comment">// key存在，替换value</span></span><br><span class="line">			head.value = value</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// key不存在，插入</span></span><br><span class="line">	h.nodes[i] = &amp;HashNode&#123;</span><br><span class="line">		key:   key,</span><br><span class="line">		value: value,</span><br><span class="line">		next:  h.nodes[i],</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	h.total++</span><br><span class="line">	<span class="keyword">if</span> h.total == <span class="built_in">cap</span>(h.nodes) &#123;<span class="comment">//当前元素数量等于哈希数组的容量，扩容</span></span><br><span class="line">		h.remake()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HashMap)</span></span> remake() &#123;</span><br><span class="line">	capa := <span class="built_in">cap</span>(h.nodes) &lt;&lt; <span class="number">1</span>           <span class="comment">//容量翻倍</span></span><br><span class="line">	newNodes := <span class="built_in">make</span>([]*HashNode, capa) <span class="comment">//新的hash数组</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> h.nodes &#123;         <span class="comment">//遍历旧hash数组</span></span><br><span class="line">		<span class="keyword">for</span> ; v != <span class="literal">nil</span>; v = v.next &#123;</span><br><span class="line">			index := v.key.GetHash(capa)<span class="comment">//重新计算哈希值</span></span><br><span class="line">			newNodes[index] = &amp;HashNode&#123;<span class="comment">//建立新链表</span></span><br><span class="line">				key:   v.key,</span><br><span class="line">				value: v.value,</span><br><span class="line">				next:  newNodes[index],</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	h.nodes = newNodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KeyType <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h KeyType)</span></span> GetHash(mod <span class="type">int</span>) (hashCode <span class="type">int</span>) &#123;<span class="comment">//实现一个对string的哈希函数</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> h.<span class="type">string</span> &#123;</span><br><span class="line">		a := <span class="type">int</span>(v)</span><br><span class="line">		hashCode = (hashCode*<span class="number">31</span> + a) &amp; (mod - <span class="number">1</span>) <span class="comment">//mod是2的幂，直接用与代替模</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为测试代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRandomString</span><span class="params">(l <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	str := <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">	bytes := []<span class="type">byte</span>(str)</span><br><span class="line">	result := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">	r := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, bytes[r.Intn(<span class="built_in">len</span>(bytes))])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cases <span class="keyword">struct</span> &#123;</span><br><span class="line">	k, v <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">16</span>)</span><br><span class="line">	myMp := NewHashMap()</span><br><span class="line">	n := <span class="number">200000</span></span><br><span class="line"></span><br><span class="line">	c := <span class="built_in">make</span>([]cases, n)</span><br><span class="line">	cc := <span class="built_in">make</span>([]KeyType, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		k, v := GetRandomString(<span class="number">10</span>), GetRandomString(<span class="number">10</span>)</span><br><span class="line">		c[i] = cases&#123;k: k, v: v&#125;</span><br><span class="line">		cc[i] = KeyType&#123;<span class="type">string</span>: k&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	st1 := time.Now().Nanosecond()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		mp[c[i].k] = c[i].v</span><br><span class="line">	&#125;</span><br><span class="line">	st2 := time.Now().Nanosecond()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		myMp.Set(cc[i], c[i].v)</span><br><span class="line">	&#125;</span><br><span class="line">	st3 := time.Now().Nanosecond()</span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;%+v&quot;, myMp)</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		_, _ = mp[c[i].k]</span><br><span class="line">	&#125;</span><br><span class="line">	st4 := time.Now().Nanosecond()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		_, _ = myMp.Get(cc[i])</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if ok2 == false || v2 != v1 &#123;	//验证正确性</span></span><br><span class="line">		<span class="comment">// 	fmt.Println(v1)</span></span><br><span class="line">		<span class="comment">// 	fmt.Println(v2)</span></span><br><span class="line">		<span class="comment">// 	panic(&quot;bug!!!&quot;)</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">	st5 := time.Now().Nanosecond()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;standard map insert: %dms\n&quot;</span>, (st2-st1)/<span class="number">1000000</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;my map insert: %dms\n&quot;</span>, (st3-st2)/<span class="number">1000000</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;standard map find: %dms\n&quot;</span>, (st4-st3)/<span class="number">1000000</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;my map find: %dms\n&quot;</span>, (st5-st4)/<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>
    <!--文末结束语-->
    
        <div style="text-align:center;color: #ccc;font-size:24px;"> --- 本文结束 <i class="fas fa-heart"></i> The End --- </div>
    
    <!--页脚广告-->
    
    <v-divider></v-divider>
    
    <div class="post-nav">             
        
            <div class="post-nav-button float-left">
                <v-icon>chevron_left</v-icon>
                <a class="font-weight-bold text-left" href="/2022/04/14/Mysql-Log%E8%AF%A6%E8%B0%88/">
                    Mysql Log详谈
                </a>
            </div>
              
          
            <div class="post-nav-button float-right">
                <a class="font-weight-bold text-right" href="/2022/04/13/golang%E5%AE%9E%E7%8E%B0%E5%8E%8B%E7%BC%A9%E8%A1%A8%E4%BB%A5%E5%8F%8A%E8%B7%B3%E8%A1%A8/">      
                    golang实现压缩表以及跳跃表
                </a>
                <v-icon>chevron_right</v-icon>
            </div>
        
    </div>
</v-card>



        
                            <div id="mobile-footer" class="d-block d-md-none">
                                <v-divider></v-divider>
                                <div id="mobile-footer-content">
                                    <span>Theme: <a target="_blank" rel="noopener" href="https://github.com/kb1000fx/hexo-theme-insulin">Insulin</a> &nbsp; Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span><br>
                                    <span> &copy; 2015 - 2022 PP</span>
                                </div>
                            </div>                   
                        </v-col>                                            
                    </v-row>
                </v-container>
            </v-content>
        </v-app>
    </div>
    
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify@2.2.30"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-base64@3.5.2/base64.min.js"></script>

<script src="/js/main.js"></script>




    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://cdn.jsdelivr.net/npm/mermaid@8.4.8/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({
        startOnLoad: true,
        theme: "default"
    });</script>





</body>
</html>